"""Generate prioritized security recommendations from Gabriel findings."""

from __future__ import annotations

from collections.abc import Iterable, Sequence
from dataclasses import dataclass
from enum import Enum

from ..knowledge import Note
from ..selfhosted import CheckResult, Severity

# Base weights chosen to keep ordering stable while allowing adjustments.
_BASE_SEVERITY_WEIGHT: dict[Severity, int] = {
    "high": 90,
    "medium": 60,
    "low": 30,
}


class RiskTolerance(Enum):
    """Represents how aggressively Gabriel should flag recommendations."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


_RISK_ADJUSTMENT: dict[RiskTolerance, dict[Severity, int]] = {
    RiskTolerance.LOW: {"high": 15, "medium": 25, "low": 30},
    RiskTolerance.MEDIUM: {"high": 0, "medium": 0, "low": 0},
    RiskTolerance.HIGH: {"high": -15, "medium": -25, "low": -30},
}

# Minimum score thresholds help suppress noise when the user accepts more risk.
_MINIMUM_SCORE: dict[RiskTolerance, int] = {
    RiskTolerance.LOW: 0,
    RiskTolerance.MEDIUM: 10,
    RiskTolerance.HIGH: 35,
}

_FOCUS_BONUS = 20
_NOTE_FOCUS_BONUS = 10
_SEVERITY_ORDER = {"high": 0, "medium": 1, "low": 2}


@dataclass(frozen=True, slots=True)
class Recommendation:
    """Represents a prioritized security action for the user."""

    slug: str
    category: str
    summary: str
    severity: Severity
    rationale: str
    remediation: tuple[str, ...]
    sources: tuple[str, ...]
    score: int


@dataclass(slots=True)
class _AggregatedFinding:
    slug: str
    category: str
    severity: Severity
    summary: str
    messages: list[str]
    remediations: list[str]


def generate_recommendations(
    *,
    findings: Sequence[CheckResult] = (),
    knowledge_notes: Sequence[Note] = (),
    focus_tags: Sequence[str] = (),
    risk_tolerance: RiskTolerance = RiskTolerance.MEDIUM,
    max_recommendations: int | None = None,
) -> list[Recommendation]:
    """Return prioritized recommendations derived from ``findings``.

    Parameters
    ----------
    findings:
        Findings generated by helpers such as :func:`gabriel.selfhosted.audit_vaultwarden`.
    knowledge_notes:
        Optional knowledge base notes that provide remediation context. Notes are matched
        against recommendation slugs and tags to enrich the rationale and source list.
    focus_tags:
        Topics that should be prioritised. Tags are matched against slugs, categories,
        and note metadata. Matching recommendations receive a score bonus.
    risk_tolerance:
        Controls how aggressive Gabriel should be when surfacing lower severity issues.
        ``RiskTolerance.LOW`` surfaces more findings, while ``RiskTolerance.HIGH`` filters
        out low-scoring recommendations.
    max_recommendations:
        Optional cap on the number of recommendations returned. ``None`` returns all
        results that clear the score threshold for the selected ``risk_tolerance``.
    """

    aggregated = _aggregate_findings(findings)
    focus_normalized = {tag.lower() for tag in focus_tags if tag}
    note_matches = list(knowledge_notes)

    recommendations: list[Recommendation] = []
    for entry in aggregated.values():
        severity: Severity = entry.severity
        score = _BASE_SEVERITY_WEIGHT[severity] + _RISK_ADJUSTMENT[risk_tolerance][severity]

        if focus_normalized and _matches_focus(entry, focus_normalized):
            score += _FOCUS_BONUS

        sources = [entry.slug]
        rationale_segments: list[str] = list(entry.messages)

        matched_notes = list(_match_notes(entry.slug, note_matches))
        for note, summary in matched_notes:
            sources.append(note.identifier)
            rationale_segments.append(f"Guidance: {summary}")
            if focus_normalized and _note_matches_focus(note, focus_normalized):
                score += _NOTE_FOCUS_BONUS

        if score < _MINIMUM_SCORE[risk_tolerance]:
            continue

        remediation = tuple(entry.remediations)
        rationale = " ".join(rationale_segments)
        recommendation = Recommendation(
            slug=entry.slug,
            category=entry.category,
            summary=entry.summary,
            severity=severity,
            rationale=rationale,
            remediation=remediation,
            sources=tuple(dict.fromkeys(sources)),
            score=score,
        )
        recommendations.append(recommendation)

    recommendations.sort(
        key=lambda item: (
            -item.score,
            _SEVERITY_ORDER[item.severity],
            item.category,
            item.slug,
        )
    )

    if max_recommendations is not None:
        limit = max(max_recommendations, 0)
        return recommendations[:limit]
    return recommendations


def _aggregate_findings(findings: Sequence[CheckResult]) -> dict[str, _AggregatedFinding]:
    aggregated: dict[str, _AggregatedFinding] = {}
    for finding in findings:
        entry = aggregated.get(finding.slug)
        if entry is None:
            aggregated[finding.slug] = _AggregatedFinding(
                slug=finding.slug,
                category=_derive_category(finding.slug),
                severity=finding.severity,
                summary=finding.message,
                messages=[finding.message],
                remediations=[finding.remediation],
            )
            continue

        if finding.message not in entry.messages:
            entry.messages.append(finding.message)

        if finding.remediation not in entry.remediations:
            entry.remediations.append(finding.remediation)

        if _SEVERITY_ORDER[finding.severity] < _SEVERITY_ORDER[entry.severity]:
            entry.severity = finding.severity
            entry.summary = finding.message

    return aggregated


def _derive_category(slug: str) -> str:
    primary, *_ = slug.split("-", 1)
    return primary.replace("_", "-") or slug


def _matches_focus(entry: _AggregatedFinding, focus: set[str]) -> bool:
    slug = entry.slug.lower()
    category = entry.category.lower()
    if any(tag in slug or tag in category for tag in focus):
        return True

    for message in entry.messages:
        message_lower = message.lower()
        if any(tag in message_lower for tag in focus):
            return True
    return False


def _note_matches_focus(note: Note, focus: set[str]) -> bool:
    tags = {tag.lower() for tag in note.tags}
    if tags & focus:
        return True
    for token in note.iter_tokens():
        if token in focus:
            return True
    return False


def _match_notes(slug: str, notes: Sequence[Note]) -> Iterable[tuple[Note, str]]:
    tokens = {slug.lower()}
    tokens.update(part.lower() for part in slug.replace("-", "_").split("_"))

    for note in notes:
        note_tokens = {token.lower() for token in note.iter_tokens()}
        if not tokens & note_tokens:
            continue
        yield note, _summarize_note(note)


def _summarize_note(note: Note) -> str:
    title = note.title.strip() if note.title else note.identifier
    lines = [line.strip() for line in note.content.splitlines() if line.strip()]
    if not lines:
        return title
    snippet = lines[0]
    if len(snippet) > 160:
        snippet = snippet[:157].rstrip() + "..."
    return f"{title}: {snippet}"


__all__ = [
    "Recommendation",
    "RiskTolerance",
    "generate_recommendations",
]
